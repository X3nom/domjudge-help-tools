import argparse
import os
import glob
import chardet
import subprocess
import zipfile

VERBOSE = False # global variable holding whether do verbose prints or not
verb_print = lambda message: print(message) if VERBOSE else None


#============================================================
# FIX ENCODING
#============================================================

def fix_encoding_file(file_path):
    '''
    Change file's encoding to UTF-8 LE (the UNIX standard)
    '''
    verb_print(f"  fixing encoding of {file_path}")

    with open(file_path, "rb") as file:
        raw_data = file.read()
        detected_encoding = chardet.detect(raw_data)["encoding"]

    # Read the file with the detected encoding
    try:
        with open(file_path, "r", encoding=detected_encoding) as file:
            content = file.read()
    except:
        verb_print(f"ERROR: skipping \"{file_path}\", the file could not be processed!")
        return 1
    
    # Normalize line endings to LF and prepare UTF-8 content
    normalized_content = content.replace("\r\n", "\n").replace("\r", "\n")
    
    # Write the file back with UTF-8 encoding
    with open(file_path, "w", encoding="utf-8", newline="\n") as file:
        file.write(normalized_content)



def fix_encoding_dir(path, recursive=False):
    '''
    Change all contained files encoding to UTF-8 LE (the UNIX standard)
    '''
    for f in glob.glob(f"{path}/**", recursive=recursive):
        if(os.path.isfile(f)):
            fix_encoding_file(f)



def fix_encoding(args :argparse.Namespace):
    verb_print(f"TASK: fix-encoding of {args.path}")

    
    if os.path.isdir(args.path):
        verb_print(f"  directory detected, processing")
        fix_encoding_dir(args.path, args.recursive)


    elif os.path.isfile(args.path):
        fix_encoding_file(args.path)

    else:
        print(f"Error: {args.path} is not a valid file or directory!")
        return 1


    verb_print("TASK DONE!")



#============================================================
# GENERATE / CHECK
#============================================================

def gen_check_res(args :argparse.Namespace, gen=True):

    test_i = 1
    for in_file in glob.glob(f"**/*in*", root_dir=args.path, recursive=True):

        in_file_path = f"{args.path}/{in_file}"

        dir_path = f"{args.path}/{os.path.dirname(in_file)}"
        dir_name = os.path.basename(dir_path)

        with open(in_file_path, "r") as f:
            in_txt = f.read()


        if(gen): cmd = args.generate_answers
        else: cmd = args.verify_answers

        process = subprocess.run(
            cmd,
            input=in_txt,
            text=True, # Treat input and output as strings
            capture_output=True, # Capture stdout and stderr
            shell=True
        )
        if process.returncode != 0:
            print(f"Error: '{cmd}' failed on '{in_file_path}' with exit code {process.returncode}")

        ans_txt = process.stdout
        

        if gen:
            with open(f"{dir_path}/ans.txt", "w") as f:
                f.write(ans_txt)

        else:
            out_files = glob.glob(f"*ans*", root_dir=dir_path) + glob.glob(f"*out*", root_dir=dir_path)

            if len(out_files) != 1:
                print(f"Error: missing .out/.ans file in {dir_path}")
                continue

            with open(f"{dir_path}/{out_files[0]}", "r") as f:
                orig_ans_txt = f.read()
            
            if ans_txt != orig_ans_txt:
                print(f"Warning: answer in \"{dir_name}\" does NOT Match answer generated with \"{cmd}\"")
            else:
                verb_print(f"  answer in {dir_name} matching")

            

#============================================================
# ZIP
#============================================================



def make_import_zip(args :argparse.Namespace):
    zipf = zipfile.PyZipFile(f"{args.name}.zip", "w")
    zipf.mkdir("data")
    zipf.mkdir("data/secret")

    zipf.writestr("problem.yaml", f"# autogenerated by testcase-help.py\nname: '{args.name}'")

    test_i = 1
    for in_file in glob.glob(f"**/*in*", root_dir=args.path, recursive=True):

        dir_path = f"{args.path}/{os.path.dirname(in_file)}"
        dir_name = os.path.basename(dir_path)

        zipf.write(f"{args.path}/{in_file}", f"data/secret/{test_i}.in")
        zipf.writestr(f"data/secret/{test_i}.desc", dir_name)

        out_files = glob.glob(f"*ans*", root_dir=dir_path) + glob.glob(f"*out*", root_dir=dir_path)

        if len(out_files) != 1:
            print(f"Error: missing .out/.ans file in {dir_path}")

        else:
            zipf.write(f"{dir_path}/{out_files[0]}", f"data/secret/{test_i}.ans")
        

    zipf.close()





def main():
    global VERBOSE
    arg_parser = argparse.ArgumentParser()

    arg_parser.add_argument(
        "path",
        metavar="PATH",
        help="Path to a file or directory"
    )
    arg_parser.add_argument(
        "-V", "--verbose",
        action="store_true",
        help="enable verbose output"
    )
    arg_parser.add_argument(
        "-r", "--recursive",
        action="store_true",
        help="process directories recursively"
    )
    arg_parser.add_argument(
        "-f", "--fix-encoding",
        action="store_true",
        help="fix encoding of file(s) to UTF-8 LF"
    )
    arg_parser.add_argument(
        "-g", "--generate-answers",
        metavar="CMD",
        help="run CMD on every in.txt and generate out.txt"
    )
    arg_parser.add_argument(
        "-v", "--verify-answers",
        metavar="CMD",
        help="run CMD for in.txt and verify correctness of out.txt"
    )
    arg_parser.add_argument(
        "-z", "--make-zip",
        action="store_true",
        help="create mass upload zip from directory"
    )
    arg_parser.add_argument(
        "-n", "--name",
        default="unnamed",
        help="specify name for zip"
    )

    args = arg_parser.parse_args()
    VERBOSE = args.verbose # set global VERBOSE (used by verbose print)


    if args.fix_encoding: # fix encodingss
        if fix_encoding(args) == 1: return 1


    if args.generate_answers is not None:
        gen_check_res(args)

    if args.verify_answers is not None:
        gen_check_res(args)

    
    if args.make_zip:
        make_import_zip(args)




if __name__ == "__main__":
    exit(main())